// Generated by CoffeeScript 1.7.1
(function() {
  var BAP, TRM, TYPES, XML2JS, alert, badge, debug, echo, help, info, log, mk_request, njs_fs, parser, parser_options, rpr, warn, whisper;

  njs_fs = require('fs');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'rss';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  BAP = require('coffeenode-bitsnpieces');

  mk_request = require('request');

  XML2JS = require('xml2js');

  parser_options = {
    trim: true,
    explicitRoot: false,
    explicitArray: true
  };

  parser = new XML2JS.Parser(parser_options);

  this.normalize_tags = function(tags) {

    /* Given a list of strings, return a 'typographically' sorted list where
      * all strings are lower-cased,
      * all strings are trimmed of peripheral whitespace,
      * all empty, blank and repeated strings are removed.
     */
    var R, seen_tags, tag, _i, _len;
    R = [];
    seen_tags = {};
    for (_i = 0, _len = tags.length; _i < _len; _i++) {
      tag = tags[_i];
      tag = tag.toLowerCase();
      tag = tag.trim();
      if (tag === '') {
        continue;
      }
      if (seen_tags[tag] != null) {
        continue;
      }
      seen_tags[tag] = tag;
      R.push(tag);
    }
    R.sort();
    return R;
  };

  this.read = function(request_options, handler) {
    var Z;
    Z = [];
    return mk_request(request_options, (function(_this) {
      return function(error, response, body) {
        if (error != null) {
          return handler(error);
        }
        if (response.statusCode !== 200) {
          return handler(new Error("something went wrong"));
        }
        return parser.parseString(body, function(error, json) {
          var channel, entry, item, tag, tags, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
          if (error != null) {
            return handler(error);
          }
          warn(json['channel'].length);
          _ref = json['channel'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            channel = _ref[_i];
            Z.push((entry = []));
            _ref1 = channel['item'];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              item = _ref1[_j];
              entry['date_txt'] = item['pubDate'][0];
              entry['title'] = item['title'][0];
              entry['link'] = item['link'][0];
              entry['summary'] = item['description'][0];
              entry['content'] = item['content:encoded'][0];
              entry['tags'] = tags = {};
              _ref2 = _this.normalize_tags(item['category']);
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                tag = _ref2[_k];
                tags[tag] = 1;
              }
            }
          }
          return handler(null, Z);
        });
      };
    })(this));
  };

}).call(this);
